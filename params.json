{"name":"clj-gpio","tagline":"A basic library for reading, writing and watching GPIO signals on a Raspberry PI, in a Clojure REPL-friendly way.","body":"[![Build Status](https://travis-ci.org/peterschwarz/clj-gpio.svg)](https://travis-ci.org/peterschwarz/clj-gpio)\r\n\r\n# clj-gpio\r\n\r\nA basic library for reading, writing and watching GPIO signals on a Raspberry\r\nPi, in a Clojure REPL-friendly way.\r\n\r\n## Usage\r\n\r\nAdd the following to your `project.clj`\r\n\r\n    [clj-gpio 0.1.0]\r\n\r\nFire up a REPL, and require `gpio.core`.\r\n\r\n### GPIO Read/Write \r\n\r\nWe can open a basic read/write GPIO port as follows (let's say we have an LED\r\nconncted to GPIO 17):\r\n\r\n    user=> (require '[gpio.core :refer :all] :reload)\r\n    nil\r\n    user=> (def port (open-port 17))\r\n    #'user/port\r\n\r\nTo read the value of the port, we can do the following:\r\n\r\n    user=> (read-value port)\r\n    :low\r\n\r\nOr, more conveniently, we can deref it:\r\n\r\n    user=> @port\r\n    :low\r\n\r\nTo set values on the port, The port needs to be configured for `out` mode:\r\n\r\n    user=> (set-direction! port :out)\r\n\r\nThis also works with `'out` and `\"out\"`.  A value can be written to the port\r\nas follows:\r\n\r\n    user=> (write-value! port :high)\r\n\r\nWith our LED connected to GPIO 17, we should see it turned on.  We can also\r\nread back the value and see that `(= :high @port)`.\r\n\r\n### GPIO Listening.\r\n\r\nWe can also pull events off of a GPIO port by using `open-channel-port`.  In\r\naddition to setting directions, values etc, we set the edge change that we'll\r\nlisten for, and we can create a `core.async` channel from which can receive\r\nvalues. \r\n\r\nFor example (if we have a push button on GPIO 18):\r\n\r\n    user=> (def ch-port (open-channel-port 18))\r\n    #'user/ch-port\r\n    user=> (set-direction! ch-port :in)\r\n    nil\r\n    user=> (set-edge! ch-port :both) ; or :falling, :rising, and :none to disable \r\n    nil\r\n\r\n We'll also set the bit to :high when the button pressed:\r\n\r\n    user=> (set-active-low! ch-port true) \r\n    nil\r\n\r\nLet's turn on the LED we defined in the Read/Write example above when our\r\nbutton is pressed: \r\n\r\n    user=> (def ch (create-edge-channel ch-port))\r\n    #'user/ch\r\n    user=>  (require '[clojure.core.async :as a :refer [go <!]])\r\n    nil\r\n    user=> (go (loop []\r\n             (when-let [value (<! ch)]\r\n                (write-value! port value)\r\n                (recur))))\r\n    #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@1197ad0>\r\n\r\n\r\nWhen we're finished with the channel, we call:\r\n\r\n     user=> (a/close! ch)\r\n     nil\r\n\r\nAnd clean up our ports:\r\n\r\n    user=> (close! port)\r\n    nil\r\n    user=> (close! ch-port)\r\n    nil\r\n\r\n## Development\r\n\r\nFirst compile the java sources:\r\n\r\n    lein javac\r\n\r\nthen fire up your REPL and require `gpio.core` as usual.\r\n\r\nNote, the edge channel will only operate on the Raspberry PI platform.\r\n\r\n## License\r\n\r\nCopyright Â© 2014 Peter Schwarz\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}